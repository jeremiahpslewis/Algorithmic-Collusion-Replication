%% Model of algorithms and competition


classdef model
    
    % Model properties
    properties
        
        % Primitives
        n = 2                   % Number of firms
        alpha = 0.15            % Learning parameter
        beta = 4e-6             % Learning parameter
        delta = 0.95            % Discount factor
        mu = 0.25               % Product differentiation
        c = 1                   % Marginal cost
        a = 2                   % 
        a0 = 0                  % 
        k = 15                  %
        
        % Derived properties
        A                       %
        Ap                      %
        p_minmax                %
        pi_minmax               %
        PI                      %
        Q                       % Q-function of the firms
        Qp                      % Q-function of the platform
        sdim                    % Dimension of the state
        s0                      % Initial state
        
        % Other properties
        filename
        
    end
    
            
    
    % Model functions
    methods (Static)
        
        % Get action space of the platform
        function [Ap, kp] = init_actions_platform(game)
            Ap = perms(1:game.n);
            kp = size(Ap, 1);
        end

        
     
        % Compute Demand
        function d = demand(game, p, order)
            o = game.Ap(order, :);
            e = exp((game.a - p) / game.mu) .* game.gamma.^o;
            d = e / (sum(e) + exp(game.a0 / game.mu));
        end
        
        

        % Compute payoffs
        function pi = profits(game, p, order)
            
            % Compute demand
            d = game.demand(game, p, order);
            
            % Set fees
            firm_fee = ones(1, game.n) * game.equivalent_fee;
            platform_fee = ones(1, game.n) * game.equivalent_fee;
            if contains(game.fmat, "self")
                firm_fee(1) = 0;
            end
            
            % Compute profits
            pi = zeros(1, game.n+1);
            if contains(game.fmat, "quantity")
                pi(1:game.n) = (p - game.c - firm_fee) .* d;
                pi(end) = sum(platform_fee .* d);
            elseif contains(game.fmat, "revenue")
                pi(1:game.n) = (p .* (1 - firm_fee) - game.c) .* d;
                pi(end) = sum(platform_fee .* p .* d);
            elseif contains(game.fmat, "profit")
                pi(1:game.n) = (p - game.c) .* d .* (1 - firm_fee);
                pi(end) = sum(platform_fee .* (p - game.c) .* d);
            else
                pi(1:game.n) = (p - game.c) .* d;
                pi(end) = 0;
            end
        end


    
        % Compute first order condition
        function zero = foc(game, p, order)
            
            % Compute demand
            d = game.demand(game, p, order);
            
            % Set fees
            fee = ones(game.n, 1) * game.equivalent_fee;
            if contains(game.fmat, "self")
                fee(1) = 0;
            end
            
            % Compute FOC
            if contains(game.fmat, "quantity")
                zero = 1 - (p - game.c - fee) .* (1 - d) / game.mu;
            elseif contains(game.fmat, "revenue")
                zero = 1 - (p * (1 - fee) - game.c) .* (1 - d) / game.mu;
            else
                zero = 1 - (p - game.c) .* (1 - d) / game.mu;
            end
        end


    
        % Compute first order condition of a monopolist
        function zero = foc_monopoly(game, p, order)
            
            % Compute demand
            d = game.demand(game, p, order);
            d1 = fliplr(d);
            p1 = fliplr(p);
            
            % Set fees
            fee = ones(game.n, 1) * game.equivalent_fee;
            if contains(game.fmat, "self")
                fee(1) = 0;
            end
            
            % Compute FOC
            if contains(game.fmat, "quantity")
                zero = 1 - (p - game.c - fee) .* (1 - d) / game.mu + (p1 - game.c - fee) .* d1 / game.mu;
            elseif contains(game.fmat, "revenue")
                zero = 1 - (p .* (1 - fee) - game.c) * (1 - d) ./ game.mu + (p1 * (1 - fee) - game.c) .* d1 / game.mu;
            else
                zero = 1 - (p - game.c) .* (1 - d) / game.mu + (p1 - game.c) .* d1 / game.mu;
            end
        end


    
        % Computes competitive and monopoly prices
        function [p, pi] = compute_p_competitive_monopoly(game, order)
            
            % Init
            p = zeros(2, game.n);
            pi = zeros(2, game.n+1);
            options = optimoptions('fsolve','Display','off');
            options.Algorithm = 'levenberg-marquardt';
            p0 = ones(1, game.n) * 2;
            
            % Compute competitive prices and profits
            p(1,:) = fsolve(@(x) game.foc(game, x, order), p0, options);
            pi(1,:) = game.profits(game, p(1,:), order);
            
            % Compute monopolistic prices and profits
            p(2,:) = fsolve(@(x) game.foc_monopoly(game, x, order), p0, options);
            pi(2,:) = game.profits(game, p(2,:), order);
        end



        % Compute fee that gives same revenue as if current fee was a revenue fee
        function equivalent_fee = compute_equivalent_fee(game)
            if isempty(regexp(game.fmat, "revenue|quantity", 'ONCE'))
                equivalent_fee = game.fee;
                return 
            end
            
            % Compute revenue with profit feee
            temp = model.init(game, "fmat", "nofee");
            p_minmax = game.compute_p_competitive_monopoly(temp, 1);
            d = game.demand(game, p_minmax(:,1), 1);
            profitfee_revenue = game.fee * sum((p_minmax(:,1) - game.c) .* d);
            
            % Compute equivalent fees
            if contains(game.fmat, "revenue")
                equivalent_fee = profitfee_revenue / sum(p_minmax(:,1) .* d);
            elseif contains(game.fmat, "quantity")
                equivalent_fee = profitfee_revenue / sum(d);
            end
        end
        
        
        
        % Get action space of the firms
        function A = init_actions_firms(game)
            a = linspace(min(game.p_minmax(1,:)), max(game.p_minmax(2,:)), game.k-2);
            delta = a(2) - a(1);
            A = linspace(min(a) - delta, max(a) + delta, game.k);
        end
        
        
        
        % Get state dimension and initial state
        function [s, subj_s, s0] = init_state(game)
            s = [game.k, game.k, game.kp];
        	subj_s = [game.k, game.k, game.kp];
        	s0 = ones(1, length(game.s));
        end
        
        
        
        % Initialize Profits (k^n x kp x n) and Q function (n x #s x k)
        function PI = init_PI(game)
            
            % Generate all possible action combinations
            statespace = [ones(1, game.n) * game.k, game.kp];
            c = [];
            for i=statespace
                c = [c, {1:i}];
            end
            all_actions = combvec(c{:})';
            
            % Compute profits
            PI = zeros([statespace, game.n+1]);
            for i=1:size(all_actions,1)
                a = all_actions(i,:);
                p = game.A(a(1:game.n));
                pi = game.profits(game, p, a(game.n+1));
                for n=1:game.n+1
                    idxcell = num2cell([a, n]);
                    linear_idx = sub2ind(size(PI), idxcell{:});
                    PI(linear_idx) = pi(n);
                end
            end
            
        end 
        
        
        
        % Init Q
        function [Q, Qp] = init_Q(game)
            Q = zeros([game.n, game.subj_s, game.k]);
            Qp = zeros(game.s);
            for n=1:game.n+1
                if n < game.n
                    pi = reshape(mean(game.PI(:, :, :, n), [2-n, game.n+1]), game.k, 1);
                    Q(n,:,:,:,:) = repmat(pi, 1, game.k, game.kp, game.k) / (1 - game.delta);
                else
                    pi = mean(game.PI(:, :, :, n), 1:game.n);
                    Qp = repmat(pi, game.k, game.k, 1) / (1 - game.delta);
                end
            end
        end
        
        
        
        % Get subjective state
        function ss = get_subj_state(s, n)
            ss = [n, s(n), s(3-n), s(end)];
        end
        
        
        
        % Get next state and profits
        function [s1, pi] = next_state(game, a)
            pi = reshape(game.PI(a(1), a(2), a(3), :), 1, game.n+1);
            s1 = a;
        end
            
        
        
        % Init preprocess
        function game = init(game0, varargin)
            
            % Init 
            game = game0;
            
            % Add properties and record filename
            for k=2:2:size(varargin,2)
                game.(varargin{k-1}) = varargin{k};
                if isstring(varargin{k})
                    game.filename = sprintf('%s_%s.%s', game.filename, varargin{k-1}, varargin{k});
                elseif ismember(varargin{k-1}, ["verbose", "graphs"]) == false
                    game.filename = sprintf('%s_%s.%.0f', game.filename, varargin{k-1}, varargin{k}*100);
                end
            end
            
            % If file exists, load it and terminate
            if isfile(sprintf("../output/games/%s.mat", game.filename))
                load(sprintf("../output/games/%s.mat", game.filename), "game");
                return
            end
            
            % Set properties
            [game.Ap, game.kp] = game.init_actions_platform(game);
            [game.p_minmax, game.pi_minmax] = game.compute_p_competitive_monopoly(game, 1);
            game.equivalent_fee = game.compute_equivalent_fee(game);
            game.A = game.init_actions_firms(game);
            [game.s, game.subj_s, game.s0] = game.init_state(game);
            game.PI = game.init_PI(game);
            [game.Q, game.Qp] = game.init_Q(game);
        end
        
        
    end
end